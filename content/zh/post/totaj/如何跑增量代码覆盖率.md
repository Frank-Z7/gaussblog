+++
title = "如何跑增量代码覆盖率" 
date = "2022-05-05" 
tags = ["覆盖率"] 
archives = "2022-05" 
author = "彭炯" 
summary = "如何跑增量代码覆盖率"
img = "/zh/post/totaj/title/img.png" 
times = "17:30"
+++

全量代码覆盖率统计：
1. 下载安装lcov工具（版本 >= 1.14），  http://ltp.sourceforge.net/coverage/lcov.php
```shell
[pengjiong@localhost ~]$ lcov -v
lcov: LCOV version 1.14
```
2. 增加插桩函数用于收集结果：在代码根目录下执行：
```shell
sed -i '/NotifyProcessActive();/i __gcov_flush();'  src/gausskernel/process/postmaster/postmaster.cpp
sed -i 'N;256 i extern "C" void __gcov_flush();'   src/gausskernel/process/postmaster/postmaster.cpp
```
执行完可以git diff  src/gausskernel/process/postmaster/postmaster.cpp查看插桩是否成功。
```shell
[pengjiong@localhost openGauss-server]$ git diff src/gausskernel/process/postmaster/postmaster.cpp
diff --git a/src/gausskernel/process/postmaster/postmaster.cpp b/src/gausskernel/process/postmaster/postmaster.cpp
index ea2c611f2..61d044431 100755
--- a/src/gausskernel/process/postmaster/postmaster.cpp
+++ b/src/gausskernel/process/postmaster/postmaster.cpp
@@ -252,6 +252,7 @@ static bool isNeedGetLCName = true;
 
 #define IS_FD_TO_RECV_GSSOCK(fd) \
     ((fd) == t_thrd.postmaster_cxt.sock_for_libcomm || (fd) == t_thrd.libpq_cxt.listen_fd_for_recv_flow_ctrl)
+extern "C" void __gcov_flush();
 
 /* These two are only here before of the SSL multithread initialization of OpenSSL component */
 #include "ssl/gs_openssl_client.h"
@@ -4546,6 +4547,7 @@ static void pmdie(SIGNAL_ARGS)
             break;
     }
 
+__gcov_flush();
     NotifyProcessActive();
 
     gs_signal_setmask(&t_thrd.libpq_cxt.UnBlockSig, NULL);
```
3. configure时增加编译选项："-fprofile-arcs -ftest-coverage" 和 "LDFLAGS='-lgcov'"是必须要新增的选项（其他选项请根据实际情况调整）
```shell
./configure CC=g++ CFLAGS='-O0 -fprofile-arcs -ftest-coverage' --prefix=/XXX --enable-debug --enable-cassert --enable-thread-safety --without-readline --without-zlib --gcc-version=7.3.0 --3rd=/XXX  LDFLAGS='-lgcov'
```
4. 正常执行make && make install
5. 然后正常执行fastcheck或者其他LLT用例即可
6. 用例运行完后，执行 gs_ctl stop -D xxx 停止gaussdb，开始准备收集覆盖率信息
7. 在代码根目录下执行：
```shell
lcov --capture --directory . --output-file coverage.info
```
然后会在根目录生成coverage.info文件
```shell
[pengjiong@localhost openGauss-server]$ ll coverage.info 
-rw-------. 1 pengjiong pengjiong 20M Apr 26 16:31 coverage.info
```
8. 编辑coverage.info文件，找到/xxx/src/test/whitebox/knl_whitebox_test.cpp这一行，将其修改为文件的正确路径
9. 接下来，使用生成的info文件转换为可视化的html文件，在代码根目录执行：
```shell
genhtml --no-prefix --no-sort coverage.info -o results
```
10. 执行成功显示覆盖率如下：
```
Writing directory view page.
Overall coverage rate:
  lines......: 15.1% (144084 of 957019 lines)
  functions..: 18.9% (12059 of 63944 functions)
```
11. 同时在根目录下生成results文件夹，将results文件夹下载到windows上，用浏览器打开results目录下的index.html文件，即可看到此次覆盖率的全部情况。也可以点击文件夹或者文件查看到具体文件，具体函数的覆盖率。

增量代码覆盖率统计：
在全量代码覆盖率结果的基础上，通过增量代码的diff文件，生成增量代码覆盖率。
1. 得到基线代码和修改后的新代码的diff文件，<font color=red>建议拉取两份完全干净的代码进行比较，以免其他文件影响最终结果<font color=red>。
```
diff -r  -N -x ".git" -x "*.gcov" -u /home/workspace/openGauss-server_base /home/workspace/openGauss-serveer_increment >> diff.txt
```
-r 表示递归，子目录也产生输出
-N 文件不存在当做空文件，比如新版本增加了一个文件，此选项会将每一行都输出
-x 表示排除，比如.git不需要
-u 是lcov需要的格式
2. 由全量覆盖率结果（coverage.info）和diff文件，生成增量覆盖率结果。addlcov工具下载地址：https://github.com/Dragonliu2018/addlcov
```
addlcov --rc lcov_branch_coverage=1 --diff coverage.info  diff.txt -o increment.info --strip $dep --path $new_Addr
```
coverage.info：前面得到的全量覆盖率文件路径
increment.info：输出的增量覆盖率文件路径
$new_Addr: 新代码路径
$dep：$new_Addr代码路径深度，即分隔符”/”的个数(包括结尾的)，可通过以下命令获取
```shell
dep=`echo $new_Addr |sed -e 's/\/*$//g' | awk -F"/" '{print NF}'`
```
注意，<font color=red>所有文件路径全部使用绝对路径，如果coverage.info文件中部分文件在增量修改后被删除了，在coverage.info里面把那一行删除</font>
3. 收集增量覆盖率结果，同全量的操作一样：
```shell
genhtml --rc lcov_branch_coverage=1 --no-prefix --no-sort increment.info -o incremen_results
```