+++
title = "openGauss数据库源码解析——慢SQL检测"
date ="2021-12-9"
tags =["openGauss安装"]
archives ="2021-12"
author ="baikaishui"
summary ="openGauss数据库源码解析——慢SQL检测"
times ="20:20"
+++
#openGauss数据库源码解析——慢SQL检测

##**慢SQL检测的定义：**

基于历史SQL语句信息进行模型训练，并用训练好的模型进行SQL语句的预测，利用预测结果判断该SQL语句是否是潜在的慢SQL。当发现潜在的慢SQL后，开发者便可以进行针对性优化或者风险评估，以防业务上线后发生问题。

##**慢SQL检测的功能：**

上线业务预检测：上线一批新业务前，使用SQL诊断功能评估此次上线业务的预估执行时长，便于用户参考是否应该修改上线业务。workload分析：能够对现有workload进行分析，将现有workload自动分为若干类别，并依次分析此类别SQL语句执行代价，以及各个类别之间的相似程度。

##**首先，明确一下慢SQL发现的几个不同阶段，及其对应解决的问题。**

阶段1：对用户输入的一批业务SQL语句进行分析，推断SQL语句执行时间的快慢，进而可以将评估为慢SQL的语句识别出来。

阶段2：对识别出的潜在慢SQL进行根因诊断，判断这些SQL语句是因为什么慢，例如比较常见的原因可能是数据量过大、SQL语句自身过于复杂、容易产生并发的锁冲突、没有创建索引导致全表扫描等等。

阶段3：对于已经识别出来的慢SQL语句的可能问题源，给出针对性的解决方案，譬如可以提示用户进行SQL语句的改写、创建索引等。

目前openGauss已具备阶段1的能力，正在推进阶段2能力，同时发布了部分阶段3的能力，如索引推荐功能。业内对于上述第一阶段的主要实现方法大部分是通过执行计划进行估计的，第二阶段大多是通过构建故障模式库、通过启发式规则来实现的，有了上述前两个阶段的准备，第三阶段的实现往往是比较独立的。学术界对于第一阶段的研究比较多，第二阶段采用常规的构建故障模式库的方法实现已经能取得比较好的效果了，因此并不是研究的热点，而第三阶段的工作又相对独立，可以单独作为一个领域进行研究。

##**基于执行计划的DNN模型：**

![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-a0155d62-7c76-44c0-8ca0-644fbcebb6b7.png)  

功能流程：

![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-2470d485-1f71-4f9a-b7f9-8df79843f8a8.png)  

该算法是将执行计划中的算子信息输入到深度学习网络中，从而对执行时间进行预测的。对于每个算子，收集左右子树的向量化特征、优化器代价及执行时间，输入与之对应的模型中，预测该算子的向量化特征及执行时间等。上述过程是个自底向上的过程。

##**例如——Join操作预测流程**

![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-763a81c7-b907-412d-a043-cc67e1c6d3d0.png)  

该流程图显示了一个join操作的预测流程，其左右子树均为Scan算子，将两个Scan算子通过对应的模型预测出的向量化特征、执行时间，以及该join算子的优化器评估代价作为入参，输出join算子模型得到该操作的向量化特征及预测出的执行时间。

上述技术的缺点。  
（1） 需要通过已预测算子不断修正模型，预测过程会较慢。  
（2） 对环境变化感知差，如数据库参数变化会使得原模型几乎完全失效。  
（3） 预测过程依赖待测语句的执行计划，加重了数据库的负荷，对于OLTP场景格外不适用。

##基于执行计划的MART（multiple additive regression trees，多重累加回归树）模型，主要包含离线训练模块和在线预测模块。他们的功能如下所示。

 ![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-5956992c-432e-4853-97c8-57f71fca288b.png)

**离线训练阶段：**针对数据库每种类型的算子（如Table Scan，Merge Join，Sort…），分别训练其对应的模型，用于估算此算子的开销。此外，使用单独的训练阶段，可为不同的算子选择适当的缩放函数。最后，形成带缩放函数的不同的回归树模型。

**在线预测阶段：**计算出执行计划中所有算子的特征值。然后，使用特征值为算子选择合适的模型，并使用它来估算执行时间。

##**功能流程：**

![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-973086cb-e4cb-40f2-abc2-98233bb73447.png)  

##基于执行计划MART模型技术调优技术的缺点。

1.泛用性较差，强依赖训练好的算子模型，遇到例如用户自定义函数的未知语句时，预测效果会较差。

2.缩放函数依赖于先验结果，对于超出范围的特征值效果无法保证。

3.预测过程依赖待测语句的执行计划，加重了数据库的负荷，很难推广到OLTP场景中。

##**慢SQL检测采取的策略：**

![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-56ce6c57-4130-402a-bf1c-18d01f846389.png)  

##**基于SQL模板化的流程**

![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-8eb7d06c-0348-4883-8a9f-e3ee76b49347.png)  

##基于SQL模板化的流程类似于基于执行计划MART模型技术调优技术，他的具体流程如下：

1.获取SQL流水数据。

2.检测本地是否存在对应实例的历史模板信息，如果存在，则加载该模板信息，如果不存在，则对该模板进行初始化。

3.基于SQL数据，提取SQL的粗粒度模板信息。粗粒度模板表示将SQL中表名、列名和其他敏感信息去除之后的SQL语句模板，该模板只保留最基本的SQL语句骨架。

4.基于SQL数据，提取SQL细粒度的模板信息。细粒度模板表示在粗粒度模板信息的基础上保留表名、列名等关键信息的SQL语句模板。细粒度模板相对粗粒度模板保留了更多SQL语句的信息。

5.执行训练过程时，首先构造SQL语句的基于粗粒度模板和细粒度模板信息，例如粗粒度模板ID、执行平均时间、细模板执行时间序列、执行平均时间和基于滑动窗口计算出的平均执行时间等。最后将上述模板信息进行储存。

6.执行预测过程时，首先导入对应实例的模板信息，如果不存在该模板信息，则直接报错退出；否则继续检测是否存在该SQL语句的粗粒度模板信息，如果不存在，则基于模板相似度计算方法在所有粗粒度模板里面寻找最相似的N条模板，之后基于KNN（K近邻）算法预测出执行时间；如果存在粗粒度模板，则接着检测是否存在近似的细粒度模板，如果不存在，则基于模板相似度计算方法在所有细粒度模板里面寻找最相似的N条模板，之后基于KNN预测出执行时间；如果存在匹配的细粒度模板，则基于当前模板数据，直接返回对应的执行时间。

##**实现代码：**

![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-6121c222-f7c6-4f31-9fca-cadded23a147.png)  

 ![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-7ee30873-03d5-421c-bbb7-51860ef202f7.png)

##**基于深度学习的执行流程**

![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-aa63931a-ff58-49a6-a88c-2f38a977c554.png)  

1.获取SQL流水。

2.在训练过程中，首先判断是否存在历史模型，如果存在，则导入模型进行增量训练；如果不存在历史模型，则首先利用word2vector算法对SQL语句进行向量化，即图8-11中的SQL embeding过程。而后创建深度学习模型，将该SQL语句向量化的结果作为输入特征。基于训练数据进行训练，并将模型保存到本地。值得一提的是，该深度学习模型的最后一个全连接层网络的输出结果作为该SQL语句的特征向量。

3.在预测过程中，首先判断是否存在模型，如果模型不存在，则直接报错退出；如果存在模型，则导入模型，并利用word2vector算法将待预测的SQL语句进行向量化，并将该向量输入到深度学习网络中，获取该神经网络的最后一个全连接层的输出结果，即为该SQL语句的特征向量。最后，利用余弦相似度在样本数据集中进行寻找，找到相似度最高的SQL语句，将该结果返回即为该待预测SQL语句的预估执行时间。当然，如果是基于最新SQL语句执行时间数据集训练出的深度学习模型，则模型的回归预测结果也可以作为预估执行时间。

##**实现代码：**

![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-8cdb6977-81bd-4e4a-b840-99da3d3facdf.png)  

![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-a7424067-b725-41fe-a0e1-92d7d3ef3e1b.png)  

##**总体流程代码解析**

![](https://oss-emcsprod-public.modb.pro/image/editor/20211206-42feeab5-e4de-41e6-a704-fbec10987aff.png)

  

参考文章：[Gauss松鼠会源码解析](https://blog.csdn.net/GaussDB/article/details/119989581?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163876954016780269849143%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=163876954016780269849143&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-119989581.pc_v2_rank_blog_default&utm_term=%E6%BA%90%E7%A0%81%E6%A3%80%E6%B5%8B&spm=1018.2226.3001.4450)